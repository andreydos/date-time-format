{"version":3,"file":"date-time-format.min.js","sources":["../src/lib/utils.js","../src/lib/formater-core.js"],"sourcesContent":["function formatKeys(key) {\n    return ({\n        YYYY: ['getFullYear', 4],\n        YY: ['getFullYear', 2],\n        // extra increment field for getMonth\n        MM: ['getMonth', 2, 1],\n        DD: ['getDate', 2],\n        HH: ['getHours', 2],\n        mm: ['getMinutes', 2],\n        ss: ['getSeconds', 2],\n        ms: ['getMilliseconds', 3],\n    })[key];\n}\n\nconst utils = {\n    formatKeys,\n};\n\nexport default utils;\n","import utils from './utils';\n\nfunction Formatter(constructorFormat) {\n    let globalFormat;\n    let output;\n\n    if (typeof constructorFormat !== 'string') {\n        globalFormat = 'HH:mm:ss (YYYY-MM-DD)';\n    } else {\n        globalFormat = constructorFormat;\n    }\n\n    function parseNext(parseToFormat, dateObject) {\n        const regex = /(?=(YYYY|YY|MM|DD|HH|mm|ss|ms))\\1([:/]*)/;\n        const match = regex.exec(parseToFormat);\n        const date = dateObject || new Date();\n\n        if (match) {\n            const keyProps = utils.formatKeys(match[1]);\n            const paddedPatternValue = `00${(date[keyProps[0]]() + (keyProps[2] || 0)).toString()}`;\n            const cleanPatternValue = paddedPatternValue.slice(-keyProps[1]) + (match[2] || '');\n            const format = parseToFormat.replace(match[0], cleanPatternValue);\n\n            parseNext(format, date);\n        } else {\n            output = parseToFormat;\n        }\n\n        return output;\n    }\n\n    this.now = (format) => {\n        let outputFormat;\n\n        if (typeof format !== 'string') {\n            outputFormat = globalFormat;\n        } else {\n            outputFormat = format;\n        }\n\n        return parseNext(outputFormat);\n    };\n\n    this.parse = function parse(format, date) {\n        if (constructorFormat) {\n            console.log('Since format specified globally in the constructor use \"parseWithFormat\" function instead');\n\n            return undefined;\n        }\n\n        let dateObj;\n        let outputFormat;\n\n        if (typeof format !== 'string') {\n            outputFormat = globalFormat;\n        } else {\n            outputFormat = format;\n        }\n\n        if (!date || Number.isNaN(new Date(date).getDate())) {\n            dateObj = new Date();\n        } else {\n            dateObj = new Date(date);\n        }\n\n        return parseNext(outputFormat, dateObj);\n    };\n\n    this.parseWithFormat = () => {\n        console.log('Not realized yet.');\n    };\n\n    return this;\n}\n\nexport { Formatter as default };\n"],"names":["utils","regex","match","exec","date","dateObject","Date","keyProps","formatKeys","paddedPatternValue","toString","cleanPatternValue","slice","format","parseToFormat","replace","globalFormat","output","now","outputFormat","parseNext","parse","log","dateObj","Number","isNaN","getDate","parseWithFormat"],"mappings":"2LAcA,GAAMA,GAAQ,YAdd,WAAyB,OACb,uBAAA,qBAAA,oBAAA,iBAAA,kBAAA,oBAAA,oBAAA,yBAAA,KAaE,CAAd,OCZA,YAAsC,gBAUY,IACpCC,GAAQ,2CACRC,EAAQD,EAAME,IAANF,IACRG,EAAOC,GAAc,GAAIC,WAEpB,IACDC,GAAWP,EAAMQ,UAANR,CAAiBE,EAAM,CAANA,CAAjBF,EACXS,OAA0B,CAACL,EAAKG,EAAS,CAATA,CAALH,KAAuBG,EAAS,CAATA,GAAe,CAAtCH,CAAD,EAA2CM,QAA3C,GAC1BC,EAAoBF,EAAmBG,KAAnBH,CAAyB,CAACF,EAAS,CAATA,CAA1BE,GAA0CP,EAAM,CAANA,GAAY,EAAtDO,EACpBI,EAASC,EAAcC,OAAdD,CAAsBZ,EAAM,CAANA,CAAtBY,UAJnB,sBAdAE,GACAC,WAE6B,QAA7B,aACe,6BAwBdC,IAAM,WAAY,IACfC,YAEkB,QAAlB,eAMGC,IATX,OAYKC,MAAQ,aAA6B,0BAE1BC,IAAI,gGAKZC,GACAJ,WAEkB,QAAlB,iBAMA,IAASK,OAAOC,KAAPD,CAAa,GAAIlB,KAAJ,IAAeoB,OAAf,EAAbF,EACC,GAAIlB,MAEJ,GAAIA,KAAJ,IAGPc,MAtBX,OAyBKO,gBAAkB,UAAM,SACjBL,IAAI,oBADhB,EAIO"}